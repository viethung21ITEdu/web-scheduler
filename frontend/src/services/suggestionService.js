import locationPreferenceService from './locationPreferenceService';

// Danh s√°ch c√°c lo·∫°i ƒë·ªãa ƒëi·ªÉm v√† t·ª´ kh√≥a t∆∞∆°ng ·ª©ng
const PLACE_CATEGORIES = {
  'Qu√°n c√† ph√™': [
    'cafe', 'coffee shop', 'c√† ph√™', 'coffee', 'caf√©', 'six', 'giangnam', 'keybox', 'v·ªëi',
    'Highlands Coffee', 'Starbucks', 'Trung Nguy√™n', 'Ph√∫c Long',
    'C·ªông C√† ph√™', 'The Coffee House', 'Milano Coffee',
    'qu√°n c√† ph√™', 'qu√°n coffee', 'c√† ph√™ s·ªØa ƒë√°'
  ],
  'Qu√°n ƒÉn': [
    'qu√°n ƒÉn', 'ƒÉn', 'ƒÉn u·ªëng', 'nh√† h√†ng', 'cƒÉn tin', 'cƒÉn tin UIT', 'cƒÉn tin ƒë·∫°i h·ªçc',
    'qu√°n c∆°m', 'qu√°n ph·ªü', 'qu√°n b√∫n', 'qu√°n b√°nh m√¨', 'qu√°n nem', 'b√∫n ƒë·∫≠u', 'minh m·∫´n',
    'b√∫n b√≤ Hu·∫ø', 'c∆°m t·∫•m', 'b√°nh x√®o', 'l·∫©u', 'n∆∞·ªõng', 'bbq',
    'KFC', 'McDonald', 'Lotteria', 'Jollibee', 'Gogi House',
    'Ph·ªü 2000', 'M√≥n Hu·∫ø', 'B√∫n ch·∫£', 'B√°nh cu·ªën', 'restaurant'
  ],
  'R·∫°p phim': ['CineStar', 'Galaxy Cinema', 'CGV', 'Lotte Cinema', 'phim'],
  'Si√™u th·ªã': ['si√™u th·ªã', 't·∫°p ho√°', 'b√°ch ho√° xanh'],
  'C√¥ng vi√™n': ['c√¥ng vi√™n', 'c√¥ng vi√™n th√†nh ph·ªë', 'khu vui ch∆°i', 's√¢n ch∆°i', 'ph·ªë ƒëi b·ªô'],
  'Trung t√¢m th∆∞∆°ng m·∫°i': ['mall', 'shopping center', 'Vincom', 'AEON'],
  'Karaoke': ['karaoke', 'ktv', 'h√°t'],
  'Ph√≤ng gym': ['gym', 'fitness', 'th·ªÉ d·ª•c'],
  'Th∆∞ vi·ªán': ['library', 'th∆∞ vi·ªán'],
  'B·∫£o t√†ng': ['museum', 'b·∫£o t√†ng']
};

class SuggestionService {
  // Cache ƒë·ªÉ l∆∞u k·∫øt qu·∫£ t√¨m ki·∫øm
  static searchCache = new Map();
  static cacheTimeout = 30 * 60 * 1000; // 30 ph√∫t
  
  // Cache cho suggestions d·ª±a tr√™n fingerprint c·ªßa nh√≥m
  static suggestionsCache = new Map();
  static suggestionsCacheTimeout = 60 * 60 * 1000; // 1 gi·ªù

  // T·∫°o fingerprint t·ª´ d·ªØ li·ªáu nh√≥m ƒë·ªÉ cache suggestions
  static createGroupFingerprint(groupLocationData) {
    // T·∫°o string duy nh·∫•t t·ª´ t·∫•t c·∫£ location v√† preferences
    const dataString = groupLocationData
      .map(member => {
        const location = member.location || '';
        const preferences = JSON.stringify(member.preferences || {});
        const otherPreference = member.otherPreference || '';
        return `${member.id || member.username}:${location}:${preferences}:${otherPreference}`;
      })
      .sort() // Sort ƒë·ªÉ ƒë·∫£m b·∫£o th·ª© t·ª± kh√¥ng ·∫£nh h∆∞·ªüng
      .join('|');
    
    // T·∫°o hash ƒë∆°n gi·∫£n t·ª´ string
    let hash = 0;
    for (let i = 0; i < dataString.length; i++) {
      const char = dataString.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    return Math.abs(hash).toString(16);
  }

  // T√≠nh to√°n th·ªùi gian d·ª± ki·∫øn cho qu√° tr√¨nh t·∫°o suggestions
  static calculateEstimatedTime(locationCount, preferenceCount) {
    // Base time (gi√¢y)
    const baseTime = 5;
    
    // Th·ªùi gian cho geocoding c√°c v·ªã tr√≠ (1s/v·ªã tr√≠ + overhead)
    const geocodingTime = locationCount * 1.2 + 3;
    
    // Th·ªùi gian cho t√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm (3s/s·ªü th√≠ch + API delays)
    const searchTime = preferenceCount * 3.5 + 2;
    
    // Th·ªùi gian x·ª≠ l√Ω cu·ªëi
    const processingTime = 3;
    
    // ƒê·∫£m b·∫£o t·∫•t c·∫£ th·ªùi gian ƒë·ªÅu l√† s·ªë nguy√™n
    const total = Math.ceil(baseTime + geocodingTime + searchTime + processingTime);
    
    return {
      total: Math.floor(total), // Ch·ªâ l·∫•y ph·∫ßn nguy√™n
      breakdown: {
        base: Math.floor(baseTime),
        geocoding: Math.floor(geocodingTime),
        search: Math.floor(searchTime),
        processing: Math.floor(processingTime)
      }
    };
  }

  // L·∫•y danh s√°ch t·ª´ kh√≥a t√¨m ki·∫øm th√¥ng minh cho m·ªói category
  static getSearchKeywords(category, keywords) {
    if (category === 'Qu√°n c√† ph√™') {
      return ['cafe', 'coffee shop', 'Highlands Coffee', 'Starbucks', 'c√† ph√™'];
    } else if (category === 'Qu√°n ƒÉn') {
      return ['qu√°n ƒÉn', 'nh√† h√†ng', 'qu√°n c∆°m', 'ph·ªü', 'restaurant'];
    } else if (category === 'C√¥ng vi√™n') {
      return ['c√¥ng vi√™n', 'c√¥ng vi√™n th√†nh ph·ªë', 'khu vui ch∆°i', 's√¢n ch∆°i'];
    } else {
      // L·∫•y t·ªëi ƒëa 3 t·ª´ kh√≥a ƒë·∫ßu ti√™n cho c√°c category kh√°c
      return keywords.slice(0, 3);
    }
  }

  // T√≠nh to√°n v·ªã tr√≠ trung t√¢m c·ªßa nh√≥m
  static async calculateGroupCenter(groupLocationData) {
    const validLocations = groupLocationData.filter(member => 
      member.location && member.location.trim()
    );

    if (validLocations.length === 0) {
      // Tr·∫£ v·ªÅ t·ªça ƒë·ªô m·∫∑c ƒë·ªãnh (v√≠ d·ª•: trung t√¢m TP.HCM)
      return {
        lat: 10.8231,
        lng: 106.6297,
        address: 'TP. H·ªì Ch√≠ Minh'
      };
    }

    try {
      // Geocode t·∫•t c·∫£ ƒë·ªãa ch·ªâ ƒë·ªÉ l·∫•y t·ªça ƒë·ªô
      const coordinates = [];
      for (const member of validLocations) {
        try {
          const coords = await this.geocodeAddress(member.location);
          if (coords) {
            coordinates.push(coords);
          }
        } catch (error) {
          console.warn(`Kh√¥ng th·ªÉ geocode ƒë·ªãa ch·ªâ: ${member.location}`);
        }
      }

      if (coordinates.length === 0) {
        return {
          lat: 10.8231,
          lng: 106.6297,
          address: 'TP. H·ªì Ch√≠ Minh'
        };
      }

      // T√≠nh trung b√¨nh t·ªça ƒë·ªô
      const centerLat = coordinates.reduce((sum, coord) => sum + coord.lat, 0) / coordinates.length;
      const centerLng = coordinates.reduce((sum, coord) => sum + coord.lng, 0) / coordinates.length;

      // Reverse geocode ƒë·ªÉ l·∫•y ƒë·ªãa ch·ªâ g·∫ßn ƒë√∫ng
      const centerAddress = await this.reverseGeocode(centerLat, centerLng);

      return {
        lat: centerLat,
        lng: centerLng,
        address: centerAddress || `${centerLat.toFixed(4)}, ${centerLng.toFixed(4)}`
      };
    } catch (error) {
      console.error('L·ªói khi t√≠nh to√°n v·ªã tr√≠ trung t√¢m:', error);
      return {
        lat: 10.8231,
        lng: 106.6297,
        address: 'TP. H·ªì Ch√≠ Minh'
      };
    }
  }

  // Mapping t·ª´ preference ID sang category name
  static PREFERENCE_MAPPING = {
    'cafe': 'Qu√°n c√† ph√™',
    'restaurant': 'Qu√°n ƒÉn', 
    'park': 'C√¥ng vi√™n',
    'cinema': 'R·∫°p phim',
    'mall': 'Trung t√¢m th∆∞∆°ng m·∫°i',
    'library': 'Th∆∞ vi·ªán',
    'karaoke': 'Karaoke',
    'gym': 'Ph√≤ng gym',
    'supermarket': 'Si√™u th·ªã',
    'museum': 'B·∫£o t√†ng'
  };

  // Ph√¢n t√≠ch s·ªü th√≠ch chung c·ªßa nh√≥m
  static analyzeGroupPreferences(groupLocationData) {
    const allPreferences = {};
    const memberCount = groupLocationData.length;

    console.log('üîç B·∫Øt ƒë·∫ßu ph√¢n t√≠ch preferences cho', memberCount, 'th√†nh vi√™n');

    // ƒê·∫øm s·ªë l∆∞·ª£ng th√†nh vi√™n th√≠ch m·ªói lo·∫°i ƒë·ªãa ƒëi·ªÉm
    groupLocationData.forEach((member, index) => {
      console.log(`üë§ Th√†nh vi√™n ${index + 1} (${member.full_name || member.username}):`, {
        hasPreferences: !!member.preferences,
        preferencesType: typeof member.preferences,
        preferences: member.preferences
      });

      if (member.preferences && typeof member.preferences === 'object') {
        Object.keys(member.preferences).forEach(prefId => {
          console.log(`  - Checking preference ${prefId}: ${member.preferences[prefId]}`);
          if (member.preferences[prefId]) {
            // Map t·ª´ preference ID sang category name
            const categoryName = this.PREFERENCE_MAPPING[prefId] || prefId;
            console.log(`  ‚úÖ Mapped ${prefId} ‚Üí ${categoryName}`);
            allPreferences[categoryName] = (allPreferences[categoryName] || 0) + 1;
          }
        });
      } else {
        console.log(`  ‚ùå Kh√¥ng c√≥ preferences h·ª£p l·ªá`);
      }
    });

    console.log('üìä T·ªïng k·∫øt preferences:', allPreferences);

    // S·∫Øp x·∫øp theo ƒë·ªô ph·ªï bi·∫øn
    const sortedPrefs = Object.entries(allPreferences)
      .sort(([,a], [,b]) => b - a)
      .map(([category, count]) => ({
        category,
        count,
        percentage: Math.round((count / memberCount) * 100)
      }));

    return sortedPrefs;
  }

  // Geocoding ƒë·ªãa ch·ªâ th√†nh t·ªça ƒë·ªô
  static async geocodeAddress(address) {
    try {
      const cacheKey = `geocode_${address}`;
      
      // Check cache
      if (this.searchCache.has(cacheKey)) {
        const cached = this.searchCache.get(cacheKey);
        if (Date.now() - cached.timestamp < this.cacheTimeout) {
          return cached.data;
        }
        this.searchCache.delete(cacheKey);
      }

      // Th√™m delay ƒë·ªÉ tr√°nh rate limit
      await new Promise(resolve => setTimeout(resolve, 1000));

      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`
      );
      
      if (!response.ok) throw new Error('Geocoding failed');
      
      const data = await response.json();
      
      if (data && data.length > 0) {
        const result = {
          lat: parseFloat(data[0].lat),
          lng: parseFloat(data[0].lon)
        };
        
        // Cache k·∫øt qu·∫£
        this.searchCache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });
        
        return result;
      }
      
      return null;
    } catch (error) {
      console.error('L·ªói geocoding:', error);
      return null;
    }
  }

  // Reverse geocoding t·ªça ƒë·ªô th√†nh ƒë·ªãa ch·ªâ
  static async reverseGeocode(lat, lng) {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`
      );
      
      if (!response.ok) throw new Error('Reverse geocoding failed');
      
      const data = await response.json();
      return data.display_name || null;
    } catch (error) {
      console.error('L·ªói reverse geocoding:', error);
      return null;
    }
  }

  // T√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm xung quanh v·ªã tr√≠ trung t√¢m
  static async searchPlacesNearby(center, category, radius = 5000) {
    try {
      const cacheKey = `places_${center.lat.toFixed(4)}_${center.lng.toFixed(4)}_${category}`;
      
      // Check cache
      if (this.searchCache.has(cacheKey)) {
        const cached = this.searchCache.get(cacheKey);
        if (Date.now() - cached.timestamp < this.cacheTimeout) {
          console.log(`üì¶ Cache hit cho ${category}`);
          return cached.data;
        }
        this.searchCache.delete(cacheKey);
      }

      // S·ª≠ d·ª•ng Nominatim search v·ªõi timeout
      const keywords = PLACE_CATEGORIES[category] || [category];
      
      console.log(`üåê API call cho ${category} t·∫°i ${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`);
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout ƒë·ªÉ t√¨m nhi·ªÅu h∆°n
      
              try {
          // T·∫°o search query th√¥ng minh d·ª±a tr√™n ƒë·ªãa ch·ªâ
          let searchArea = '';
          if (center.address) {
            if (center.address.includes('Dƒ© An') || center.address.includes('B√¨nh D∆∞∆°ng')) {
              searchArea = 'Binh Duong Vietnam';
            } else if (center.address.includes('Th·ªß ƒê·ª©c')) {
              searchArea = 'Thu Duc Ho Chi Minh City Vietnam';
            } else if (center.address.includes('TP.HCM') || center.address.includes('Ho Chi Minh')) {
              searchArea = 'Ho Chi Minh City Vietnam';
            } else {
              // L·∫•y 2 ph·∫ßn cu·ªëi c·ªßa ƒë·ªãa ch·ªâ (th∆∞·ªùng l√† qu·∫≠n/huy·ªán v√† t·ªânh/th√†nh)
              const addressParts = center.address.split(',');
              if (addressParts.length >= 3) {
                searchArea = addressParts.slice(-3).join(',').trim();
              } else {
                searchArea = center.address;
              }
            }
          } else {
            searchArea = `${center.lat.toFixed(4)},${center.lng.toFixed(4)}`;
          }
          
          // T√¨m ki·∫øm v·ªõi nhi·ªÅu t·ª´ kh√≥a kh√°c nhau cho k·∫øt qu·∫£ t·ªët h∆°n
          let allPlaces = [];
          const searchKeywords = this.getSearchKeywords(category, keywords);
          
          for (const searchQuery of searchKeywords) {
            const searchUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery + ' ' + searchArea)}&limit=10&addressdetails=1`;
            console.log(`üîó Search URL: ${searchUrl} (Query: ${searchQuery}, Area: ${searchArea})`);
            
            const response = await fetch(searchUrl, { 
                signal: controller.signal,
                headers: {
                  'User-Agent': 'GroupLocationApp/1.0'
                }
              }
            );
            
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            console.log(`üìä Raw API response for "${searchQuery}":`, data);
            
            // Th√™m v√†o danh s√°ch t·ªïng
            allPlaces.push(...data.filter(place => place.display_name && place.lat && place.lon));
            
            // Delay gi·ªØa c√°c request ƒë·ªÉ tr√°nh rate limit
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          
          clearTimeout(timeoutId);
        
                  // Lo·∫°i b·ªè duplicate v√† x·ª≠ l√Ω d·ªØ li·ªáu
          const uniquePlaces = new Map();
          allPlaces.forEach(place => {
            // S·ª≠ d·ª•ng place_id l√†m key ƒë·ªÉ lo·∫°i b·ªè duplicate
            if (!uniquePlaces.has(place.place_id)) {
              uniquePlaces.set(place.place_id, place);
            }
          });

          let places = Array.from(uniquePlaces.values())
            .map(place => {
              const distance = this.calculateDistance(center.lat, center.lng, parseFloat(place.lat), parseFloat(place.lon));
              return {
                id: place.place_id,
                name: this.extractPlaceName(place.display_name),
                category: category,
                address: place.display_name,
                lat: parseFloat(place.lat),
                lng: parseFloat(place.lon),
                distance
              };
            })
            .filter(place => {
              // L·ªçc theo kho·∫£ng c√°ch
              if (place.distance > 12) return false;
              
              // L·ªçc ƒë·∫∑c bi·ªát ƒë·ªÉ lo·∫°i b·ªè c√°c k·∫øt qu·∫£ kh√¥ng mong mu·ªën
              const nameAndAddress = (place.name + ' ' + place.address).toLowerCase();
              
              if (category === 'C√¥ng vi√™n') {
                // Lo·∫°i b·ªè c√°c t·ª´ kh√≥a kh√¥ng mong mu·ªën cho c√¥ng vi√™n
                const unwantedKeywords = [
                  'university', 'college', 'school', 'ƒë·∫°i h·ªçc', 'tr∆∞·ªùng', 'h·ªçc vi·ªán',
                  'parking', 'b√£i ƒë·ªó', 'ch·ªó ƒë·ªó xe', 'khu ƒë·ªó xe',
                  'industrial', 'khu c√¥ng nghi·ªáp', 'nh√† m√°y',
                  'business park', 'khu kinh doanh',
                  'apartment', 'chung c∆∞', 'building', 't√≤a nh√†'
                ];
                
                const hasUnwantedKeyword = unwantedKeywords.some(keyword => 
                  nameAndAddress.includes(keyword.toLowerCase())
                );
                
                if (hasUnwantedKeyword) {
                  console.log(`üö´ Filtered out "${place.name}" - contains unwanted keyword for park`);
                  return false;
                }
              }
              
              if (category === 'Qu√°n ƒÉn') {
                // Lo·∫°i b·ªè c√°c c√¥ng ty/nh√† m√°y th·ª±c ph·∫©m cho qu√°n ƒÉn
                const unwantedKeywords = [
                  'company', 'corporation', 'corp', 'ltd', 'c√¥ng ty', 'cty',
                  'factory', 'plant', 'nh√† m√°y', 'x√≠ nghi·ªáp', 'khu c√¥ng nghi·ªáp',
                  'processing', 'manufacturing', 'distribution', 'ch·∫ø bi·∫øn', 's·∫£n xu·∫•t',
                  'industrial', 'industry', 'c√¥ng nghi·ªáp', 
                  'warehouse', 'kho', 'depot',
                  'wholesale', 'b√°n s·ªâ', 'ph√¢n ph·ªëi',
                  'supplier', 'supply', 'cung c·∫•p',
                  'import', 'export', 'xu·∫•t nh·∫≠p kh·∫©u',
                  'food processing', 'beverage company', 'th·ª±c ph·∫©m ch·∫ø bi·∫øn'
                ];
                
                const hasUnwantedKeyword = unwantedKeywords.some(keyword => 
                  nameAndAddress.includes(keyword.toLowerCase())
                );
                
                if (hasUnwantedKeyword) {
                  console.log(`üö´ Filtered out "${place.name}" - contains unwanted keyword for restaurant`);
                  return false;
                }
              }
              
              return true;
            })
            .sort((a, b) => a.distance - b.distance) // S·∫Øp x·∫øp theo kho·∫£ng c√°ch tƒÉng d·∫ßn
            .slice(0, 5); // TƒÉng l√™n 5 ƒë·ªãa ƒëi·ªÉm cho m·ªói lo·∫°i

          console.log(`‚úÖ T√¨m ƒë∆∞·ª£c ${places.length} ƒë·ªãa ƒëi·ªÉm cho ${category}`);
          
          // Kh√¥ng s·ª≠ d·ª•ng fallback n·ªØa ƒë·ªÉ test v·ªõi d·ªØ li·ªáu th·∫≠t
        
        // Cache k·∫øt qu·∫£
        this.searchCache.set(cacheKey, {
          data: places,
          timestamp: Date.now()
        });
        
        // Th√™m delay nh·ªè ƒë·ªÉ tr√°nh rate limit cho l·∫ßn g·ªçi ti·∫øp theo
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        return places;
        
      } catch (fetchError) {
        clearTimeout(timeoutId);
        if (fetchError.name === 'AbortError') {
          console.warn(`‚è∞ Timeout t√¨m ki·∫øm ${category}`);
        } else {
          console.warn(`‚ö†Ô∏è L·ªói API cho ${category}:`, fetchError.message);
        }
        return [];
      }
      
    } catch (error) {
      console.error(`‚ùå L·ªói t√¨m ki·∫øm ${category}:`, error);
      return [];
    }
  }



  // Extract clean place name from display_name
  static extractPlaceName(displayName) {
    const parts = displayName.split(',');
    let name = parts[0].trim();
    
    // Lo·∫°i b·ªè s·ªë nh√† n·∫øu c√≥
    name = name.replace(/^\d+\s*/, '');
    
    // Gi·ªõi h·∫°n ƒë·ªô d√†i t√™n
    if (name.length > 50) {
      name = name.substring(0, 50) + '...';
    }
    
    return name || 'ƒê·ªãa ƒëi·ªÉm kh√¥ng t√™n';
  }

  // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm (Haversine formula)
  static calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // B√°n k√≠nh Tr√°i ƒê·∫•t (km)
    const dLat = this.toRad(lat2 - lat1);
    const dLng = this.toRad(lng2 - lng1);
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * 
      Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  static toRad(value) {
    return value * Math.PI / 180;
  }

  // T√≠nh t·ªïng kho·∫£ng c√°ch t·ª´ ƒë·ªãa ƒëi·ªÉm ƒë·∫øn t·∫•t c·∫£ th√†nh vi√™n
  static calculateTotalDistanceToMembers(place, memberLocations) {
    let totalDistance = 0;
    const distances = [];
    
    memberLocations.forEach((memberLoc, index) => {
      const distance = this.calculateDistance(place.lat, place.lng, memberLoc.lat, memberLoc.lng);
      distances.push(distance);
      totalDistance += distance;
    });
    
    const avgDistance = totalDistance / memberLocations.length;
    console.log(`  üìè Kho·∫£ng c√°ch ƒë·∫øn t·ª´ng th√†nh vi√™n: [${distances.map(d => d.toFixed(1)).join('km, ')}km]`);
    console.log(`  üìä T·ªïng: ${totalDistance.toFixed(1)}km, TB: ${avgDistance.toFixed(1)}km`);
    
    return { totalDistance, avgDistance, distances };
  }

  // T√≠nh ƒëi·ªÉm ph√π h·ª£p cho t·ª´ng ƒë·ªãa ƒëi·ªÉm (t·ªëi ∆∞u t·ªïng kho·∫£ng c√°ch)
  static calculateMatchRate(place, groupPreferences, memberLocations, memberCount) {
    console.log(`\nüéØ T√≠nh to√°n matchRate cho ${place.name} (${place.category})`);
    console.log(`  üìç ƒê·ªãa ƒëi·ªÉm: ${place.address}`);
    console.log(`  üë• S·ªë th√†nh vi√™n: ${memberCount}`);
    console.log(`  üìç S·ªë v·ªã tr√≠ th√†nh vi√™n: ${memberLocations.length}`);
    console.log(`  ‚ù§Ô∏è S·ªü th√≠ch nh√≥m:`, groupPreferences.map(p => `${p.category}: ${p.count}/${memberCount}`));
    
    let score = 0;
    const maxScore = 100;

    // ƒêi·ªÉm d·ª±a tr√™n s·ªü th√≠ch (40% t·ªïng ƒëi·ªÉm) - ƒëi·ªÅu ch·ªânh cho nhi·ªÅu s·ªü th√≠ch
    const categoryPref = groupPreferences.find(pref => pref.category === place.category);
    if (categoryPref) {
      // T√≠nh ƒëi·ªÉm d·ª±a tr√™n s·ªë ng∆∞·ªùi th√≠ch, kh√¥ng ph·∫£i percentage
      const memberLikeScore = (categoryPref.count / memberCount) * 30; // T·ªëi ƒëa 30 ƒëi·ªÉm
      
      // Bonus n·∫øu l√† s·ªü th√≠ch ƒë∆∞·ª£c ch·ªçn (ch·ª©ng t·ªè nh√≥m quan t√¢m)
      const selectionBonus = 10; // +10 ƒëi·ªÉm cho vi·ªác ƒë∆∞·ª£c ch·ªçn
      
      const preferenceScore = memberLikeScore + selectionBonus;
      score += preferenceScore;
      console.log(`  üìä S·ªü th√≠ch: ${categoryPref.count}/${memberCount} th√†nh vi√™n th√≠ch ‚Üí ${preferenceScore.toFixed(1)} ƒëi·ªÉm (${memberLikeScore.toFixed(1)} + ${selectionBonus} bonus)`);
    } else {
      console.log(`  üìä S·ªü th√≠ch: Kh√¥ng c√≥ ai th√≠ch ${place.category} ‚Üí 0 ƒëi·ªÉm`);
    }

    // ƒêi·ªÉm d·ª±a tr√™n t·ªëi ∆∞u t·ªïng kho·∫£ng c√°ch (50% t·ªïng ƒëi·ªÉm)
    let distanceInfo = null;
    if (memberLocations.length === 0) {
      console.log(`  üìç Kh√¥ng c√≥ v·ªã tr√≠ th√†nh vi√™n n√†o ‚Üí 0 ƒëi·ªÉm kho·∫£ng c√°ch`);
      // N·∫øu kh√¥ng c√≥ v·ªã tr√≠ n√†o, cho ƒëi·ªÉm trung b√¨nh
      const distanceScore = 25; // 50% c·ªßa ƒëi·ªÉm t·ªëi ƒëa
      score += distanceScore;
      console.log(`  üìç Default distance score: ${distanceScore} ƒëi·ªÉm`);
    } else {
      distanceInfo = this.calculateTotalDistanceToMembers(place, memberLocations);
      const avgDistance = distanceInfo.avgDistance;
      
      console.log(`  üìç Chi ti·∫øt kho·∫£ng c√°ch:`);
      distanceInfo.distances.forEach((dist, index) => {
        const memberName = memberLocations[index]?.name || `Th√†nh vi√™n ${index + 1}`;
        console.log(`    - ${memberName}: ${dist.toFixed(1)}km`);
      });
      
      let distanceScore;
      if (avgDistance <= 2) {
        // R·∫•t g·∫ßn trung b√¨nh: ƒëi·ªÉm t·ªëi ƒëa
        distanceScore = 50;
      } else if (avgDistance <= 8) {
        // G·∫ßn trung b√¨nh: ƒëi·ªÉm cao, gi·∫£m tuy·∫øn t√≠nh t·ª´ 50 xu·ªëng 0 trong kho·∫£ng 2-8km
        distanceScore = 50 * (8 - avgDistance) / 6; // 2km ƒë∆∞·ª£c 50, 8km ƒë∆∞·ª£c 0
      } else if (avgDistance <= 15) {
        // Xa trung b√¨nh: ƒëi·ªÉm th·∫•p
        distanceScore = Math.max(0, (15 - avgDistance) / 7) * 10; // T·ªëi ƒëa 10 ƒëi·ªÉm
      } else {
        // R·∫•t xa: g·∫ßn nh∆∞ 0 ƒëi·ªÉm
        distanceScore = 1;
      }
      
      score += distanceScore;
      console.log(`  üìç Kho·∫£ng c√°ch TB: ${avgDistance.toFixed(1)}km ‚Üí ${distanceScore.toFixed(1)} ƒëi·ªÉm`);
    }

    // Bonus cho ƒë·ªãa ƒëi·ªÉm c√≥ kho·∫£ng c√°ch ƒë·ªìng ƒë·ªÅu (kh√¥ng ai qu√° xa) - ch·ªâ khi c√≥ d·ªØ li·ªáu
    if (distanceInfo && distanceInfo.distances.length > 0) {
      const maxIndividualDistance = Math.max(...distanceInfo.distances);
      const minIndividualDistance = Math.min(...distanceInfo.distances);
      const distanceRange = maxIndividualDistance - minIndividualDistance;
      
      let fairnessScore = 0;
      if (distanceRange <= 3) {
        fairnessScore = 5; // R·∫•t c√¥ng b·∫±ng
      } else if (distanceRange <= 6) {
        fairnessScore = 3; // Kh√° c√¥ng b·∫±ng
      } else if (distanceRange <= 10) {
        fairnessScore = 1; // √çt c√¥ng b·∫±ng
      }
      
      score += fairnessScore;
      console.log(`  ‚öñÔ∏è ƒê·ªô c√¥ng b·∫±ng: ${distanceRange.toFixed(1)}km range ‚Üí ${fairnessScore.toFixed(1)} ƒëi·ªÉm`);
    } else {
      console.log(`  ‚öñÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu kho·∫£ng c√°ch ƒë·ªÉ t√≠nh ƒë·ªô c√¥ng b·∫±ng ‚Üí 0 ƒëi·ªÉm`);
    }

    // ƒêi·ªÉm d·ª±a tr√™n t√™n ƒë·ªãa ƒëi·ªÉm (ƒë·ªô d√†i h·ª£p l√Ω, kh√¥ng ch·ª©a s·ªë)
    let nameQualityScore = 0;
    const placeName = place.name.toLowerCase();
    
    // Bonus cho t√™n kh√¥ng ch·ª©a qu√° nhi·ªÅu s·ªë (ƒë·ªãa ch·ªâ)
    const numberCount = (placeName.match(/\d/g) || []).length;
    if (numberCount === 0) {
      nameQualityScore += 2; // T√™n s·∫°ch, kh√¥ng c√≥ s·ªë
    } else if (numberCount <= 2) {
      nameQualityScore += 1; // √çt s·ªë
    }
    
    // Bonus cho t√™n c√≥ ƒë·ªô d√†i h·ª£p l√Ω (kh√¥ng qu√° ng·∫Øn ho·∫∑c qu√° d√†i)
    if (place.name.length >= 5 && place.name.length <= 30) {
      nameQualityScore += 1;
    }
    
    // Penalty cho ƒë·ªãa ch·ªâ th√¥ (ch·ª©a nhi·ªÅu d·∫•u ph·∫©y)
    const commaCount = (place.address.match(/,/g) || []).length;
    if (commaCount <= 3) {
      nameQualityScore += 1; // ƒê·ªãa ch·ªâ g·ªçn g√†ng
    }
    
    score += nameQualityScore;
    console.log(`  üìù Ch·∫•t l∆∞·ª£ng t√™n: ${nameQualityScore.toFixed(1)} ƒëi·ªÉm (s·ªë: ${numberCount}, ƒë·ªô d√†i: ${place.name.length}, ph·∫©y: ${commaCount})`);

    const finalScore = Math.min(maxScore, Math.round(score));
    console.log(`  ‚úÖ T·ªïng ƒëi·ªÉm: ${finalScore}% cho ${place.name}`);

    return finalScore;
  }

  // T·∫°o l√Ω do ph√π h·ª£p
  static generateMatchReasons(place, groupPreferences, memberCount, memberLocations = null) {
    const reasons = [];
    
    const categoryPref = groupPreferences.find(pref => pref.category === place.category);
    if (categoryPref) {
      reasons.push(`${place.category} (${categoryPref.count}/${memberCount} th√†nh vi√™n th√≠ch)`);
    }

    // N·∫øu c√≥ th√¥ng tin v·ªã tr√≠ th√†nh vi√™n, t√≠nh to√°n kho·∫£ng c√°ch t·ªëi ∆∞u
    if (memberLocations && memberLocations.length > 0) {
      const distanceInfo = this.calculateTotalDistanceToMembers(place, memberLocations);
      const avgDistance = distanceInfo.avgDistance;
      const maxDistance = Math.max(...distanceInfo.distances);
      
      if (avgDistance <= 3) {
        reasons.push('Kho·∫£ng c√°ch trung b√¨nh r·∫•t g·∫ßn cho t·∫•t c·∫£ th√†nh vi√™n');
      } else if (avgDistance <= 6) {
        reasons.push('Kho·∫£ng c√°ch trung b√¨nh h·ª£p l√Ω cho nh√≥m');
      } else if (maxDistance <= 10) {
        reasons.push('Kh√¥ng c√≥ th√†nh vi√™n n√†o qu√° xa');
      }
      
      // Ki·ªÉm tra ƒë·ªô c√¥ng b·∫±ng
      const distanceRange = maxDistance - Math.min(...distanceInfo.distances);
      if (distanceRange <= 3) {
        reasons.push('Kho·∫£ng c√°ch ƒë·ªìng ƒë·ªÅu cho t·∫•t c·∫£ th√†nh vi√™n');
      }
    } else {
      // Fallback cho tr∆∞·ªùng h·ª£p c≈©
      if (place.distance < 2) {
        reasons.push('Kho·∫£ng c√°ch g·∫ßn nh·∫•t');
      } else if (place.distance < 5) {
        reasons.push('Kho·∫£ng c√°ch h·ª£p l√Ω');
      }
    }

    if (reasons.length === 0) {
      reasons.push('ƒê·ªãa ƒëi·ªÉm ph√π h·ª£p v·ªõi nh√≥m');
    }

    return reasons;
  }



  // Main function: T·∫°o suggestions cho nh√≥m
  static async generateSuggestions(groupId, progressCallback = null) {
    try {
      console.log('üîç B·∫Øt ƒë·∫ßu t·∫°o suggestions cho groupId:', groupId);
      
      // 1. L·∫•y d·ªØ li·ªáu v·ªã tr√≠ v√† s·ªü th√≠ch c·ªßa t·∫•t c·∫£ th√†nh vi√™n
      const response = await locationPreferenceService.getGroupLocationPreferences(groupId);
      console.log('üìç Raw response:', JSON.stringify(response, null, 2));
      
      // Extract data array t·ª´ response
      const groupLocationData = response.success ? response.data : [];
      console.log('üìç Extracted data array:', JSON.stringify(groupLocationData, null, 2));
      
      if (!groupLocationData || groupLocationData.length === 0) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu nh√≥m');
        return [];
      }

      // 2. Ki·ªÉm tra cache d·ª±a tr√™n fingerprint c·ªßa d·ªØ li·ªáu nh√≥m
      const groupFingerprint = this.createGroupFingerprint(groupLocationData);
      const cacheKey = `suggestions_${groupId}_${groupFingerprint}`;
      
      console.log('üîë Group fingerprint:', groupFingerprint);
      
      if (this.suggestionsCache.has(cacheKey)) {
        const cached = this.suggestionsCache.get(cacheKey);
        if (Date.now() - cached.timestamp < this.suggestionsCacheTimeout) {
          console.log('üì¶ Cache hit! S·ª≠ d·ª•ng suggestions ƒë√£ cache');
          console.log('üí° Kh√¥ng c√≥ th√†nh vi√™n n√†o thay ƒë·ªïi v·ªã tr√≠ ho·∫∑c s·ªü th√≠ch');
          if (progressCallback) {
            progressCallback({
              stage: 'completed',
              progress: 100,
              message: 'S·ª≠ d·ª•ng ƒë·ªÅ xu·∫•t ƒë√£ cache',
              estimatedTime: 0
            });
          }
          return cached.data;
        }
        // Cache h·∫øt h·∫°n
        this.suggestionsCache.delete(cacheKey);
        console.log('üïê Cache ƒë√£ h·∫øt h·∫°n, t·∫°o suggestions m·ªõi');
      } else {
        console.log('üÜï Kh√¥ng c√≥ cache ho·∫∑c d·ªØ li·ªáu ƒë√£ thay ƒë·ªïi, t·∫°o suggestions m·ªõi');
      }

      // 3. T√≠nh to√°n th·ªùi gian d·ª± ki·∫øn v√† b√°o c√°o progress
      const membersWithLocation = groupLocationData.filter(m => m.location && m.location.trim()).length;
      const uniquePreferences = this.analyzeGroupPreferences(groupLocationData);
      
      // T√≠nh th·ªùi gian d·ª± ki·∫øn (gi√¢y)
      const estimatedTimeCalc = this.calculateEstimatedTime(membersWithLocation, uniquePreferences.length);
      console.log(`‚è∞ ∆Ø·ªõc t√≠nh th·ªùi gian: ${estimatedTimeCalc.total}s cho ${membersWithLocation} v·ªã tr√≠ v√† ${uniquePreferences.length} s·ªü th√≠ch`);
      
      if (progressCallback) {
        progressCallback({
          stage: 'analyzing',
          progress: 10,
          message: `Ph√¢n t√≠ch ${groupLocationData.length} th√†nh vi√™n...`,
          estimatedTime: estimatedTimeCalc.total,
          details: {
            members: groupLocationData.length,
            locationsToProcess: membersWithLocation,
            preferencesToSearch: uniquePreferences.length
          }
        });
      }

      console.log('‚ù§Ô∏è S·ªü th√≠ch nh√≥m sau ph√¢n t√≠ch:', JSON.stringify(uniquePreferences, null, 2));
      
      // Debug chi ti·∫øt t·ª´ng th√†nh vi√™n
      console.log('üìã Chi ti·∫øt ƒë·∫ßy ƒë·ªß c·ªßa t·ª´ng th√†nh vi√™n:');
      groupLocationData.forEach((member, index) => {
        console.log(`  üë§ Th√†nh vi√™n ${index + 1}:`, {
          user_id: member.user_id,
          username: member.username,
          full_name: member.full_name,
          location: member.location,
          location_length: member.location ? member.location.length : 0,
          preferences: member.preferences,
          preferences_keys: member.preferences ? Object.keys(member.preferences) : [],
          preferences_values: member.preferences ? Object.values(member.preferences) : [],
          otherPreference: member.otherPreference,
          updated_at: member.updated_at
        });
      });

      if (uniquePreferences.length === 0) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ s·ªü th√≠ch n√†o ƒë∆∞·ª£c ch·ªçn');
        return [];
      }

      // 4. T√≠nh to√°n v·ªã tr√≠ trung t√¢m nh√≥m (ƒë·ªÉ t√¨m ki·∫øm)
      if (progressCallback) {
        progressCallback({
          stage: 'geocoding',
          progress: 20,
          message: `ƒêang x·ª≠ l√Ω v·ªã tr√≠ c·ªßa ${membersWithLocation}/${groupLocationData.length} th√†nh vi√™n...`,
          estimatedTime: Math.floor(estimatedTimeCalc.total - 5) // tr·ª´ ƒëi th·ªùi gian ƒë√£ qua, ch·ªâ l·∫•y ph·∫ßn nguy√™n
        });
      }
      
      console.log('üìç ƒêang t√≠nh to√°n v·ªã tr√≠ trung t√¢m...');
      const groupCenter = await this.calculateGroupCenter(groupLocationData);
      console.log('üéØ V·ªã tr√≠ trung t√¢m:', JSON.stringify(groupCenter, null, 2));

      // 5. Thu th·∫≠p v·ªã tr√≠ t·ªça ƒë·ªô c·ªßa t·∫•t c·∫£ th√†nh vi√™n (ƒë·ªÉ t√≠nh t·ªïng kho·∫£ng c√°ch)
      if (progressCallback) {
        progressCallback({
          stage: 'member_geocoding',
          progress: 40,
          message: `ƒêang geocoding v·ªã tr√≠ ${membersWithLocation}/${groupLocationData.length} th√†nh vi√™n...`,
          estimatedTime: Math.floor(estimatedTimeCalc.total - 15)
        });
      }
      
      console.log('üìç ƒêang thu th·∫≠p t·ªça ƒë·ªô t·∫•t c·∫£ th√†nh vi√™n...');
      const memberLocations = [];
      for (const member of groupLocationData) {
        if (member.location && member.location.trim()) {
          const coords = await this.geocodeAddress(member.location);
          if (coords) {
            memberLocations.push({
              ...coords,
              name: member.full_name || member.username,
              address: member.location
            });
          }
        }
      }
      console.log(`üéØ ƒê√£ c√≥ t·ªça ƒë·ªô ${memberLocations.length} th√†nh vi√™n:`, 
        memberLocations.map(m => `${m.name} (${m.lat.toFixed(4)}, ${m.lng.toFixed(4)})`));

      // 6. T√¨m ki·∫øm ƒë·ªãa ƒëi·ªÉm th·∫≠t cho T·∫§T C·∫¢ lo·∫°i s·ªü th√≠ch
      const allSuggestions = [];
      
      // T√¨m ki·∫øm cho t·∫•t c·∫£ s·ªü th√≠ch ƒë∆∞·ª£c ch·ªçn (gi·ªõi h·∫°n 2 ƒë·ªãa ƒëi·ªÉm m·ªói lo·∫°i)
      for (let i = 0; i < uniquePreferences.length; i++) {
        const pref = uniquePreferences[i];
        const searchProgress = 60 + (i / uniquePreferences.length) * 30; // 60-90%
        
        if (progressCallback) {
          progressCallback({
            stage: 'searching',
            progress: Math.round(searchProgress),
            message: `ƒêang t√¨m ki·∫øm ${pref.category} (${i + 1}/${uniquePreferences.length})...`,
            estimatedTime: Math.floor(Math.max(0, estimatedTimeCalc.total - (estimatedTimeCalc.total * searchProgress / 100)))
          });
        }
        
        console.log(`üîç T√¨m ki·∫øm ${pref.category} (${pref.count}/${groupLocationData.length} th√†nh vi√™n th√≠ch)...`);
        const places = await this.searchPlacesNearby(groupCenter, pref.category);
        console.log(`‚úÖ T√¨m th·∫•y ${places.length} ${pref.category}`);
        
        // Ch·ªâ l·∫•y 2 ƒë·ªãa ƒëi·ªÉm t·ªët nh·∫•t m·ªói lo·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o ƒëa d·∫°ng
        const limitedPlaces = places.slice(0, 2);
        
        for (const place of limitedPlaces) {
          const matchRate = this.calculateMatchRate(place, uniquePreferences, memberLocations, groupLocationData.length);
          const matchReasons = this.generateMatchReasons(place, uniquePreferences, groupLocationData.length, memberLocations);

          allSuggestions.push({
            id: `${place.category}_${place.id}`,
            name: place.name,
            category: place.category,
            address: place.address,
            matchRate,
            distance: Number(place.distance.toFixed(1)),
            priceRange: this.generatePriceRange(place.name, place.category),
            matchReasons,
            openingHours: '08:00 - 22:00',
            days: 'Th·ª© 2 - Ch·ªß nh·∫≠t',
            lat: place.lat,
            lng: place.lng
          });
        }
      }

      // 7. S·∫Øp x·∫øp theo ƒë·ªô ph√π h·ª£p v√† lo·∫°i b·ªè tr√πng l·∫∑p
      if (progressCallback) {
        progressCallback({
          stage: 'finalizing',
          progress: 95,
          message: 'ƒêang s·∫Øp x·∫øp v√† l·ªçc k·∫øt qu·∫£...',
          estimatedTime: 2 // ƒê√£ l√† s·ªë nguy√™n
        });
      }
      
      const uniqueSuggestions = allSuggestions
        .filter((suggestion, index, self) => 
          index === self.findIndex(s => s.name === suggestion.name)
        )
        .sort((a, b) => b.matchRate - a.matchRate)
        .slice(0, 20); // TƒÉng gi·ªõi h·∫°n l√™n 20 ƒë·ªÉ hi·ªÉn th·ªã ƒëa d·∫°ng h∆°n

      console.log('‚úÖ ƒê√£ t·∫°o', uniqueSuggestions.length, 'suggestions th·∫≠t');

      // 8. Cache k·∫øt qu·∫£ suggestions
      this.suggestionsCache.set(cacheKey, {
        data: uniqueSuggestions,
        timestamp: Date.now()
      });
      console.log('üíæ ƒê√£ cache suggestions v·ªõi key:', cacheKey);

      // 9. Ho√†n th√†nh v√† tr·∫£ v·ªÅ k·∫øt qu·∫£
      if (progressCallback) {
        progressCallback({
          stage: 'completed',
          progress: 100,
          message: `Ho√†n th√†nh! T√¨m th·∫•y ${uniqueSuggestions.length} ƒë·ªÅ xu·∫•t ph√π h·ª£p`,
          estimatedTime: 0
        });
      }

      return uniqueSuggestions;

    } catch (error) {
      console.error('‚ùå L·ªói khi t·∫°o suggestions:', error);
      
      // ƒê√£ t·∫Øt fallback - ch·ªâ tr·∫£ v·ªÅ m·∫£ng r·ªóng
      return [];
    }
  }

  // Generate price range based on place category and name characteristics
  static generatePriceRange(placeName = '', category = '') {
    // D·ª±a tr√™n lo·∫°i ƒë·ªãa ƒëi·ªÉm ƒë·ªÉ ∆∞·ªõc t√≠nh gi√°
    if (category.includes('Qu√°n c√† ph√™')) return '‚Ç´‚Ç´';
    if (category.includes('Qu√°n ƒÉn')) {
      // Ph√¢n t√≠ch t√™n ƒë·ªÉ ∆∞·ªõc t√≠nh m·ª©c gi√°
      const name = placeName.toLowerCase();
      if (name.includes('nh√† h√†ng') || name.includes('restaurant')) return '‚Ç´‚Ç´‚Ç´';
      if (name.includes('c∆°m') || name.includes('ph·ªü') || name.includes('b√∫n')) return '‚Ç´';
      return '‚Ç´‚Ç´';
    }
    if (category.includes('R·∫°p phim')) return '‚Ç´‚Ç´';
    if (category.includes('Karaoke')) return '‚Ç´‚Ç´‚Ç´';
    if (category.includes('Trung t√¢m th∆∞∆°ng m·∫°i')) return '‚Ç´‚Ç´';
    
    return '‚Ç´‚Ç´'; // Default
  }

  // Ch·ªâ l·∫•y cache suggestions m√† kh√¥ng t·∫°o m·ªõi
  static async getCachedSuggestions(groupId) {
    try {
      console.log('üîç Checking cache for groupId:', groupId);
      
      // 1. L·∫•y d·ªØ li·ªáu v·ªã tr√≠ v√† s·ªü th√≠ch c·ªßa t·∫•t c·∫£ th√†nh vi√™n ƒë·ªÉ t·∫°o fingerprint
      const response = await locationPreferenceService.getGroupLocationPreferences(groupId);
      const groupLocationData = response.success ? response.data : [];
      
      if (!groupLocationData || groupLocationData.length === 0) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu nh√≥m ƒë·ªÉ ki·ªÉm tra cache');
        return [];
      }

      // 2. T·∫°o fingerprint v√† ki·ªÉm tra cache
      const groupFingerprint = this.createGroupFingerprint(groupLocationData);
      const cacheKey = `suggestions_${groupId}_${groupFingerprint}`;
      
      console.log('üîë Checking cache key:', cacheKey);
      
      if (this.suggestionsCache.has(cacheKey)) {
        const cached = this.suggestionsCache.get(cacheKey);
        if (Date.now() - cached.timestamp < this.suggestionsCacheTimeout) {
          console.log('üì¶ Cache hit! Tr·∫£ v·ªÅ suggestions t·ª´ cache');
          return cached.data;
        } else {
          // Cache h·∫øt h·∫°n
          this.suggestionsCache.delete(cacheKey);
          console.log('üïê Cache ƒë√£ h·∫øt h·∫°n');
        }
      } else {
        console.log('‚ùå Kh√¥ng c√≥ cache ho·∫∑c d·ªØ li·ªáu ƒë√£ thay ƒë·ªïi');
      }
      
      return [];
    } catch (error) {
      console.error('üí• Error checking cache:', error);
      return [];
    }
  }

  // X√≥a cache suggestions cho m·ªôt nh√≥m c·ª• th·ªÉ (g·ªçi khi c√≥ thay ƒë·ªïi d·ªØ li·ªáu)
  static clearSuggestionsCache(groupId = null) {
    if (groupId) {
      // X√≥a cache cho nh√≥m c·ª• th·ªÉ
      const keysToDelete = [];
      this.suggestionsCache.forEach((value, key) => {
        if (key.startsWith(`suggestions_${groupId}_`)) {
          keysToDelete.push(key);
        }
      });
      keysToDelete.forEach(key => {
        this.suggestionsCache.delete(key);
        console.log('üóëÔ∏è ƒê√£ x√≥a cache suggestions:', key);
      });
    } else {
      // X√≥a to√†n b·ªô cache
      this.suggestionsCache.clear();
      console.log('üóëÔ∏è ƒê√£ x√≥a to√†n b·ªô cache suggestions');
    }
  }

  // Ki·ªÉm tra k√≠ch th∆∞·ªõc cache v√† d·ªçn d·∫πp n·∫øu c·∫ßn
  static cleanupCache() {
    const now = Date.now();
    
    // D·ªçn d·∫πp searchCache
    this.searchCache.forEach((value, key) => {
      if (now - value.timestamp > this.cacheTimeout) {
        this.searchCache.delete(key);
      }
    });
    
    // D·ªçn d·∫πp suggestionsCache
    this.suggestionsCache.forEach((value, key) => {
      if (now - value.timestamp > this.suggestionsCacheTimeout) {
        this.suggestionsCache.delete(key);
      }
    });
    
    console.log(`üßπ Cache cleanup completed. Search: ${this.searchCache.size}, Suggestions: ${this.suggestionsCache.size}`);
  }
}

export default SuggestionService; 